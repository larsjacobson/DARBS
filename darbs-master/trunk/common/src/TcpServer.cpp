//////////////////////////////////////////////////////////////////////////
//
// File: TcpServer.cpp
//
//////////////////////////////////////////////////////////////////////////
//
// $Id: LnTcpServer.cpp,v 1.1 2001/04/06 15:46:33 kcpw2 Exp $
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis: 
//
// Implementation file for the TcpServer class.
// 
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/03: Joe Turner: initial implementation
//
//////////////////////////////////////////////////////////////////////////

///////////////////////////// global includes ////////////////////////////   
#include <string>
#include <iostream>
#include <boost/bind.hpp>

///////////////////////////// local includes /////////////////////////////
#include "TcpServer.hpp"

///////////////////////////// namespaces /////////////////////////////////

///////////////////////////// defines ////////////////////////////////////

///////////////////////////// global variables ///////////////////////////

///////////////////////////// member functions ///////////////////////////


//////////////////////////////////////////////////////////////////////////
//
// TcpServer::TcpServer(boost::asio::io_service& ioService, int port)
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Constructor for the TcpServer class. Creates the socket manager
// (ioService) and connection acceptor, and begins accepting connections.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      TcpServer(boost::asio::io_service& ioService, int port)
//
// Where:      boost::asio::io_service& ioService: Socket IO facilitator
//             int port: The port number to bind to
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
TcpServer::TcpServer(boost::asio::io_service& ioService, int port)
    : ioService(ioService),
      acceptor(ioService,
               boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(),
                                              port)) {
    startAccept();
}

//////////////////////////////////////////////////////////////////////////
//
// TcpServer::~TcpServer()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Destructor for LnTcpServer class. Destroys any active connections.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
TcpServer::~TcpServer() {
    delete &connections;
}

//////////////////////////////////////////////////////////////////////////
//
// TcpServer::startAccept()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Start listening for new connections from client
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      startAccept()
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
void TcpServer::startAccept() {
    TcpConnection *conn = new TcpConnection(ioService);
    acceptor.async_accept(conn->getSocket(),
                          boost::bind(&TcpServer::handleAccept, this, conn,
                                      boost::asio::placeholders::error));
}

//////////////////////////////////////////////////////////////////////////
//
// TcpServer::handleAccept(TcpConnection* conn,
//                         const boost::system::error_code& error)
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// 
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      TcpServer::handleAccept(TcpConnection* conn,
//                              const boost::system::error_code& error)
//
// Where:      TcpConnection* conn: Pointer to the connection
//             const boost::system::error_code& error: Error code if
//             accept failed
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
void TcpServer::handleAccept(TcpConnection* conn,
                             const boost::system::error_code& error) {
    if (error) {
        // TODO: Should probably do something with this rather than just
        //       returning
        std::cout << error.message() << std::endl;
        return;
    }
    conn->read();
    conn->readSignal.connect(boost::bind(&TcpServer::readHandler, this,
                                         _1, _2));
    conn->errorSignal.connect(boost::bind(&TcpServer::errorHandler, this,
                                          _1, _2));
    connections.push_back(conn);
    startAccept();
}

//////////////////////////////////////////////////////////////////////////
//
// TcpServer::broadcast(std::string message,
//                      TcpConnection *avoidConnection)
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Send a message to all connected clients, except the one supplied as
// avoidConnection (generally the client which caused the broadcast in
// the first place)
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      TcpServer::broadcast(std::string message,
//                                  TcpConnection *avoidConnection)
//
// Where:      std::string message: The message to send to connected
//             clients
//             TcpConnection* avoidConnection: A connection which will
//             not be broadcast to
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
void TcpServer::broadcast(std::string message, TcpConnection *avoidConnection) {
    std::vector<TcpConnection*>::iterator i;
    for (i=connections.begin(); i<connections.end(); i++) {
        if (*i != avoidConnection) {
            (*i)->write(message);
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
// TcpServer::readHandler(std::string data, TcpConnection *connection)
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Receives read signals from connected clients, and re-broadcasts them
// as a single signal
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      TcpServer::readHandler(std::string data,
//                                    TcpConnection *connection)
//
// Where:      std::string data: Data read from a client
//             TcpConnection* connection: The connection which recieved
//             the data
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
void TcpServer::readHandler(std::string data, TcpConnection *connection) {
    readSignal(data, connection);
}

//////////////////////////////////////////////////////////////////////////
//
// TcpServer::errorHandler(const boost::system::error_code& error,
//                         TcpConnection *connection)
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Receives error signals from clients, consequetly deleting them from the
// connection pool
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      TcpServer::errorHandler(const boost::system::error_code& error
//                                     TcpConnection *connection)
//
// Where:      const boost::system::error_code& error: The error code
//             TcpConnection* connection: The connection over which the
//             error occurred
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2010/02/05: Joe Turner: Initial implementation
//
//////////////////////////////////////////////////////////////////////////
void TcpServer::errorHandler(const boost::system::error_code& error,
                             TcpConnection *connection) {
    // TODO: Should check what the error is, and possibly handle it more
    //       gracefully
    std::vector<TcpConnection*>::iterator i;
    for (i=connections.begin(); i<connections.end(); i++) {
        if (*i == connection) {
            connections.erase(i);
            delete *i;
        }
    }
}

