//////////////////////////////////////////////////////////////////////////
//
// File: LnTokenizer.cpp
//
//////////////////////////////////////////////////////////////////////////
//
// $Id: LnTokenizer.cpp,v 1.1 2001/09/06 14:22:27 kcpw2 Exp $
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis: 
//
// Implementation file for LnTokenizer class
// 
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////

///////////////////////////// global includes ////////////////////////////
#include <stdio.h>
#include <iostream>
#include <string>
#include <cctype>
#include <stdexcept>

///////////////////////////// local includes /////////////////////////////
#include "LnTokenizer.hpp"

///////////////////////////// defines ////////////////////////////////////
#define COMMENT_END_NOT_FOUND "End of comment not found"


///////////////////////////// global variables ///////////////////////////


///////////////////////////// member functions ///////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::LnTokenizer()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Basic constructor for LnTokenizer class. Sets default whitespace,
// bracket and operator characters.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      LnTokenizer()
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
LnTokenizer::LnTokenizer()
{
    // set default whitespace
    setWhitespace( WHITESPACE);

    // set default brackets
    setBrackets( BRACKETS);

    // set default operators
    setOperators( OPERATORS );
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::LnTokenizer()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Construtor for the LnTokenizer class. Sets default whitespace, bracket
// and operator characters. Sets the internal buffer to string buffer.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      LnTokenizer( string buffer)
//
// Where:      string buffer: string to be tokenized
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
LnTokenizer::LnTokenizer( std::string buffer )
{
    // set string to be tokenized
    setString( buffer );

    // set default whitespace
    setWhitespace( WHITESPACE);

    // set default brackets
    setBrackets( BRACKETS);

    // set default operators
    setOperators( OPERATORS );
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::~LnTokenizer()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Destructor for the LnTokenizer class.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    n/a
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
LnTokenizer::~LnTokenizer()
{
    // nothing here yet
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::setWhitespace()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis: 
//
// Use the characters give in string whitespace as delimiters, i.e.
// for separating tokens in strings.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      setWhitespace( string whitespace )
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
void LnTokenizer::setWhitespace( std::string whitespace )
{
    m_whitespace=whitespace;
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::setBrackets()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis: 
//
// Use the characters give in string brackets to group expressions, e.g.
// to make lists.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      setBrackets( string brackets )
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
void LnTokenizer::setBrackets( std::string brackets )
{
    m_brackets=brackets;
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::setOperators()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis: 
//
// Declares the characters give in string operators as operators. An 
// operator character is used to brake down a string into expressions that
// can be used for further processing, e.g. in a parser for a calculator.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      setOperators( string operators )
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
void LnTokenizer::setOperators( std::string operators )
{
    m_operators=operators;
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::setString()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Sets string to be tokenized to string buffer.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      setString( string buffer )
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
void LnTokenizer::setString( std::string buffer )
{
    // set string to be tokenized
    m_string = buffer;
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::getNextToken()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Cuts off the first token from internal buffer and returns it. Uses
// m_whitespace, m_brackets and m_operators as delimiters.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:     getNextToken()
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    string containing the next token
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: stdexcept::runtime_error - if comment end not found
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
// 2000/10/06: Patrick Wong : added debugging info.
//////////////////////////////////////////////////////////////////////////
std::string LnTokenizer::getNextToken()
{
	size_t cp;
	size_t idx;
	bool bDebug=false;

	int	openedBracketsCounter;
	int closedBracketsCounter;

	std::string token;
	
	if (bDebug) {
		std::cout << "debugging tokeniser..." << std::endl;
		std::cout << "<debug> m_string = " << m_string << std::endl;
	}
	// strip leading and tailing white space
	strip( m_string, BOTH, m_whitespace);

	if (bDebug) {
		std::cout << "after stripping" << std::endl;
		std::cout << "<debug> m_string = " << m_string << std::endl;
	}
	// is there anything left?
	if( m_string.length() < 1 ) // no
	{
		return LNVOID; // buffer is empty
	}
	// else get first token
  // if token starts with an open bracket,token is itself a list
	if( isOpenBracket( m_string[0]) )
	{
		// set bracket counters
		closedBracketsCounter = 0;
		openedBracketsCounter = 1;
	
		// find corresponding closing bracket
		idx = 1;
		while( ( openedBracketsCounter > closedBracketsCounter ) && ( idx < m_string.length() ))
		{
			if( isOpenBracket( m_string[idx] ) )
	    {
				openedBracketsCounter++;
			}
			else if( isCloseBracket( m_string[idx] ))
	    {
				closedBracketsCounter++;
	  	}
	    idx++;
		}
		token = m_string.substr(0,idx);
		m_string.erase(0,idx);
	}
	else if( m_string.substr(0,2) == "/*" ) // C-style comment
	{
		// find corresponding tag
		cp = m_string.find("*/");

		// if found
		if( cp !=-1 )
		{
	    token = m_string.substr(0,cp+2);
	    m_string.erase(0,cp+2);
			if (bDebug) {
				std::cout << "token is a comment" << std::endl;
				std::cout << "<debug> token = " << token << std::endl;
			}
		}
		else
		{
	    throw std::runtime_error(COMMENT_END_NOT_FOUND);
		}
	}
	else // token is a keyword or operator
	{
		cp = m_string.find_first_of( m_whitespace+m_brackets+m_operators );
		if( cp != -1 ) // delimiter was found
		{
//		edited by P.Wong on 12-09-2002.
//			if( m_operators.find(m_string[cp]) != -1 ) // token is an operator
			if( m_operators.find(m_string[0]) != -1 ) // token is an operator
			{
				token = m_string.substr(0,1);
				m_string.erase(0,1);
				if (bDebug) {
					std::cout << "token is an operator" << std::endl;
					std::cout << "<debug> token = " << token << std::endl;
				}
			}
			else // token is keyword
	    {
				token = m_string.substr(0, cp);
				m_string.erase(0,cp);
				if (bDebug) {
					std::cout << "token is a keyword" << std::endl;
					std::cout << "<debug> token = " << token << std::endl;
				}
	    }
		}
		else // rest of string is a token
		{
			token = m_string;
			m_string.erase();
			if (bDebug) {
				std::cout << "last token" << std::endl;
				std::cout << "<debug> token = " << token << std::endl;
			}
		}
	}

  // eleminate whitespaces and the beginning and the end
  strip( token, BOTH);
	if (bDebug) {
		std::cout << "after stripping" << std::endl;
		std::cout << "<debug> token = " << token << std::endl;
		std::cout << "done debugging tokeniser..." << std::endl;
	}

  // that's all folks
  return token;
}

//////////////////////////////////////////////////////////////////////////
//
// isOpenBracket()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Returns true if item is an open bracket character '{', '[' or '(', 
// otherwise false.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      isOpenBracket( char &item)
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    true  - if item is an open bracket character
//             false - if item is not an open bracket character
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
int isOpenBracket( char &item)
{ 
// edited by p.wong on 25-10-2002
//    if( item == '{' || item =='[' || item == '(' )
    if( item == '{' || item =='[' || item == '(' || item == '<')
    {
	return true;
    }
    else
    {
	return false;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// isCloseBracket()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Returns true if item is an closed bracket character '{', '[' or '(', 
// otherwise false.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      isCloseBracket( char &item)
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    true  - if item is an closed bracket character
//             false - if item is not an closed bracket character
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
int isCloseBracket( char &item)
{
// edited by p.wong on 25-10-2002
//    if( item == '}' || item ==']' || item == ')' )
    if( item == '}' || item ==']' || item == ')' || item == '>' )
    {
	return true;
    }
    else
    {
	return false;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// strip()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Deletes heading and/or tailing characters given in delim from strng.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      strip( string& strng , int mode, string delim)
//
// Where:      string& strng - reference to string to be striped
//             int mode      - HEAD, TAIL or BOTH
//             string delim  - string containing characters to be deleted
//                             from beginning, end or both
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    void
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none 
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/06/21: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
void strip( std::string& strng , int mode, std::string delim)
{
    size_t cp;

    switch( mode )
    {
    case HEAD:	
	// strip leading white space
	cp = strng.find_first_not_of(delim);
	if( cp != -1 )
	{
	    strng.erase(0,cp);
	}
	break;
    case TAIL:
	// strip trailing white space
	cp = strng.find_last_not_of(delim);
	if( (cp != -1) && (cp+1<strng.length()) )
	{
	    strng.erase( cp+1, strng.length() );
	}
	break;
    case BOTH:
	strip( strng, HEAD, delim );
	strip( strng, TAIL, delim );
	break;
    default:
	break;
    }
    return;
}

//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::getRemains()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// Returns remaining internal buffer.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      getRemains()
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    string containing the remainding internal data
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/07/07: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
std::string LnTokenizer::getRemains()
{
    // return internal buffer
    return m_string;
}


//////////////////////////////////////////////////////////////////////////
//
// LnTokenizer::getNumberOfTokens()
//
//////////////////////////////////////////////////////////////////////////
//
// Synopsis:  
//
// This function counts the number of tokens in the internal buffer.
//
//////////////////////////////////////////////////////////////////////////
//
// Usage:      getNumberOfTokens()
//
//////////////////////////////////////////////////////////////////////////
//
// Returns:    number of tokens in internal buffer
//
//////////////////////////////////////////////////////////////////////////
//
// Exceptions: none
//
//////////////////////////////////////////////////////////////////////////
//
// History:
//
// 2000/07/07: Lars Nolle: initial implementation
//
//////////////////////////////////////////////////////////////////////////
int LnTokenizer::getNumberOfTokens()
{
    LnTokenizer tokenizer( m_string );
    int num=0;
    std::string buffer;

    // while buffer is not empty
    while( (buffer=tokenizer.getNextToken() ) != LNVOID )
    {
	// count token
	num++;
    }
    return num;
}
/** replace sSrc in the string with sDes. */
std::string LnTokenizer::Replace(std::string sSrc, std::string sDes){
	std::string sToken, sTemp, sData;
	while ( ((sToken = getNextToken()) != LNVOID) ){
		if ( sToken == sSrc ){
			sData += (sDes + " ");
		}
		else {
			sData += (sToken + " ");
		}
	}
	m_string = sData;
	return sData;		
}
